---
layout: post
title: Идентификация малвари по imphash/fuzzyhash
tags: [draft]
category: [ru]
---

## Intro

Метод был описан в [оригинальной статье](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html) от Mandiant (была куплена FireEye).

imphash - один из признков, по которому можно сопоставить разные образцы с одной преступной группой. Представьте что у вас есть база данных сэмплов, некоторые из них от одних и тех же разработчиков. imphash может помочь выявить образцы, собранные одним и тем же билдером.

Для получения дополнительной информации о сэмпле, вы можете произвести поиск по сайтам с базой данных. Бывают ситуации, когда сливать файл нельзя - разработчикам будет известно, что их обнаружили. Разработчики могут распостранять разные версии малвари для разных регионов/организаций и увидев в публичном доступе свой файл, они поймут конкретное место утечки. Более безопасный метод получения информации - вы получаете imphash/fuzzyhash и ищете по нему.

Сопостовление по imphash/fuzzyhash это лишь способ получить список сэмплов, на которые надо обратить внимание (начать ручной анализ). Минусы этого способа:

- Много false positive. Одни и те же API могут использоваться никак не связанной между собой малварью
- Маленькая точность. Даже небольшое изменение списка API координально изменяет хэш. 


Код imphash из [pefile](https://github.com/erocarrera/pefile/blob/ab5f27a26c7f408aba61d02c5ec91ee8a28b1e50/pefile.py)

```python
def get_imphash(self):
        impstrs = []
        exts = ['ocx', 'sys', 'dll']
        if not hasattr(self, "DIRECTORY_ENTRY_IMPORT"):
            return ""
        for entry in self.DIRECTORY_ENTRY_IMPORT:
            if isinstance(entry.dll, bytes):
                libname = entry.dll.decode().lower()
            else:
                libname = entry.dll.lower()
            parts = libname.rsplit('.', 1)

            if len(parts) > 1 and parts[1] in exts:
                libname = parts[0]

            for imp in entry.imports:
                funcname = None
                if not imp.name:
                    funcname = ordlookup.ordLookup(entry.dll.lower(), imp.ordinal, make_name=True)
                    if not funcname:
                        raise Exception("Unable to look up ordinal %s:%04x" % (entry.dll, imp.ordinal))
                else:
                    funcname = imp.name

                if not funcname:
                    continue

                if isinstance(funcname, bytes):
                    funcname = funcname.decode()
                impstrs.append('%s.%s' % (libname.lower(),funcname.lower()))

        return md5( ','.join( impstrs ).encode() ).hexdigest()
```


Меняя местами вызов API, мы можем обходить идентификацию по imphash. В этом может помочь метод хэширования отсортированного списка, как в [этой модификации](https://github.com/malwaredb/imphash) алгоритма. Проблема в том, что ввсе популярные базы данных содержат imphash вычисленый оригинальным алгоритмом из pefile (такие как [totalhash](https://totalhash.cymru.com/), [virustotal](https://www.virustotal.com/), [virusshare](https://virusshare.com/) и т.д.). 

