---
layout: post
title: Решение тасков рутми
tags: [cracking]
category: [ru]
---

## PE x86 - AutoPE (medium)

[Ссылка на таск](https://www.root-me.org/en/Challenges/Cracking/PE-x86-AutoPE)

Файл представляет собой x86 exe, с полем ввода пароля и кнопкой, которая запускает его проверку:

![](/assets/images/ru/rootme/1.png)

Из описания следует, что:

1. используется AutoIt
2. конец файла (скорей всего имеется в виду autoit скрипт) - это только начало
3. надо обратить внимание на "WTF"

![](/assets/images/ru/rootme/2.png)

нам надо извлечь autoit скрипт из бинарника. Скачиваем [exe2aut](https://exe2aut.com/exe2aut-converter/). Закидываем наш бинарник и в итоге получаем исходный скрипт: 

![](/assets/images/ru/rootme/3.png)

Чтобы удобно просматривать, редактировать и запускать скрипт, нам надо установить [SciTE4AutoIt3](https://www.autoitscript.com/site/autoit/downloads/). Открываем скрипт, и идем в самый конец (как было сказано в подсказке). Внизу мы видим небольшое количество функций, с "wtf" в именах, то что нужно:

![](/assets/images/ru/rootme/4.png)

Только в одной из них есть проверка чего-то на равенство:

![](/assets/images/ru/rootme/5.png)

Сравниваются переменные $wtf8 и $wtf9. Давайте выведем их значение:

![](/assets/images/ru/rootme/7.png)

![](/assets/images/ru/rootme/6.png)

Очевидно, что условие никогда не будет истинным, так как эти строки не равны. Давайте изменим это условие, чтобы оно стало истиным. Меняем `$wtf8 = $wtf9` на `$wtf8 <> wtf9`:

![](/assets/images/ru/rootme/8.png)

Теперь, запустив скрипт, мы увидим InputBox!

![](/assets/images/ru/rootme/9.png)

И внутри наш флаг!

![](/assets/images/ru/rootme/10.jpg)

## HTB easy

Этот таск не из рутми, а из HTB ctf. Меня попросили помочь решить. У нас в руках 64 битный ELF бинарник:

```
casino: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=ac3d9d8a2c65ca7a0cb88af07efaec8c991c315d, for GNU/Linux 3.2.0, not stripped
```

Суть программы - считывание инпута длиной 0x1d, использование его в качестве seed для функции srand() и сравнение результата функции rand() с захардкоженым массивом: 

![](/assets/images/ru/rootme/htb_1.png)

массив:

![](/assets/images/ru/rootme/htb_2.png)

Другими словами, нам надо подать на вход такие символы (%c), на основе которых будут сгенерированы определенные "псведослучайные" значения. Интуиция подсказала, что в начале надо проверить специальные символы. Был написан следующий код:

```c
#include "stdio.h"

int main() {


        int i;
        const char* a = "-*_+=-[]{}&^%$#@!()";
        for(i = 0;i<19;i++) {
        srand(a[i]);
        printf("%x\n", rand());
};
        return 0;
}
```

В итоге удалось глазами сопоставить вывод с массивом и найти одно значение (подчеркивание) - "43383720 _"

![](/assets/images/ru/rootme/htb_3.jpg)

Уже лучше. Следующее предположение было о том, что используются ASCII символы. Для этого был написан простой брутер, который сравнивал поочередно значение из массива с каждым аски символом (от 0 до 127):

```c
#include "stdio.h"

int main() {
	int res[0x1d] = {0x244B28BE, 0x0AF77805, 0x110DFC17, 0x7AFC3A1, 0x6AFEC533,
	0x4ED659A2, 0x33C5D4B0, 0x286582B8, 0x43383720, 0x55A14FC5,
	0x19195F9F, 0x43383720, 0x63149380, 0x615AB299, 0x6AFEC533, 0x6C6FCFB8,
	0x43383720, 0x0F3DA237, 0x6AFEC533, 0x615AB299, 0x286582B8, 0x55A14FC, 0x3AE44994, 0x6D7DFE9, 0x4ED659A2, 0x0CCD4ACD, 0x57D8ED64, 0x615AB299, 0x22E9BC2A};

	int i,j, check;
	
	for(j = 0;j <= 0x1c; j++) {
		for(i = 0;i<127;i++) { 
                srand(i);
                check = rand();
		
        		if (res[j] == check)
                    printf("%c", i);
        }
	}
	return 0;
}
```

В итоге получим флаг.