---
layout: post
title: Два простых способа идентификации неизвестной малвари
tags: [malware-analysis]
category: [ru]
---

## Intro

Перед изучением неизвестного вредоносного файла, обычно пытаются выяснить 

- Является ли малварь уже известной сообществу (проанализированной)
- Принадлежность к определенному семейству (вариант известного RAT/бэкдора)
- Принадлежность к конкретной APT группе

Для этого, вычисляется хэш файла и производится поиск по общедоступным базам ([virustotal](https://www.virustotal.com/), [totalhash](https://totalhash.cymru.com/), [virusshare](https://virusshare.com/), [virusbay](https://beta.virusbay.io/), ...). Поиск может не дать результатов по причинам:

- Не все сэмплы загружаются в общедоступные базы. Бывают ситуации, когда антивирусным компаниям/исследователям сливать файл нельзя - разработчикам малвари будет известно, что их обнаружили. Они могут распространять разные версии малвари для разных регионов/организаций и увидев в публичном доступе свой файл, понять конкретное место утечки 

- Разработчики малвари могут билдить варианты одной программы, с разными ip, набором ресурсов, payload, текстом на разных языках (в случае шифровальщиков), адреса btc кошельков и т.д. В этом случае, несмотря на то, что малварь по сути одна и та же, хэш будет отличаться.

Помочь обойти эти препятствия на пути идентификации неизвестного сэмпла помогут два способа - imphash и fuzzyhash.

## imphash

imphash - это хэш, который вычисляется от списка импортируемых функций в PE файле. Пример импортируемых функций в PE файле:

![](/assets/images/ru/malware-identifying/imports.png)

> *[Официальная документация PE формата](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)*
> 
> *Более расширенное описание PE формата: [1 часть](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1), [2 часть](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2)*
>
> *Впервые, метод был описан в [отчете от FireEye](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-malware-supply-chain.pdf) в 2014 году*

Данный вид хэша решает две проблемы, описанные ранее:

 - Практически все общедоступные базы малвари прикладывают значение imphash. Поэтому вы можете найти связанные сэмплы поиском по imphash, не выдавая свой:

> *[Анонс Virustotal](https://blog.virustotal.com/2014/02/virustotal-imphash.html) о вводе imphash в своей базе*

Пример поиска по imphash на Virusshare:

![](/assets/images/ru/malware-identifying/imphash_search.png)

 - Каждый новый вариант малвари может содержать новые ip адреса, секции, ресурсы и т.д., но набор используемых функций будет неизменен

imphash может быть использован для сканирования системы на наличие подозрительных файлов. Скриптом 
[ImpHash-Generator](https://github.com/Neo23x0/ImpHash-Generator) можно создать базу хэшей "хороших" файлов в начальном состоянии ОС.

Авторы идеи imphash закоммитили патч, с алгоритмом вычисления, для популярного инструмента, для анализа PE файлов - [pefile](https://github.com/erocarrera/pefile).

> *[Конкретное место в исходниках](https://github.com/erocarrera/pefile/blob/ab5f27a26c7f408aba61d02c5ec91ee8a28b1e50/pefile.py#L3922)*
>
> *[Реализация на Go](https://github.com/omarghader/pefile-go)*

Алгоритм вычисления imphash:

```python

#DIRECTORY_ENTRY_IMPORT (list of ImportDescData instances)

def get_imphash(self):
        impstrs = []
        exts = ['ocx', 'sys', 'dll']
        if not hasattr(self, "DIRECTORY_ENTRY_IMPORT"):
            return ""
        for entry in self.DIRECTORY_ENTRY_IMPORT:
            if isinstance(entry.dll, bytes):
                libname = entry.dll.decode().lower()
            else:
                libname = entry.dll.lower()
            parts = libname.rsplit('.', 1)

            if len(parts) > 1 and parts[1] in exts:
                libname = parts[0]

            for imp in entry.imports:
                funcname = None
                if not imp.name:
                    funcname = ordlookup.ordLookup(entry.dll.lower(), imp.ordinal, make_name=True)
                    if not funcname:
                        raise Exception("Unable to look up ordinal %s:%04x" % (entry.dll, imp.ordinal))
                else:
                    funcname = imp.name

                if not funcname:
                    continue

                if isinstance(funcname, bytes):
                    funcname = funcname.decode()
                impstrs.append('%s.%s' % (libname.lower(),funcname.lower()))

        return md5( ','.join( impstrs ).encode() ).hexdigest()
```

Алгоритм:

- Парсинг [Import Directory Table](https://docs.microsoft.com/ru-ru/windows/win32/debug/pe-format?redirectedfrom=MSDN#import-directory-table)
- Создание списка из элементов вида "имя_библиотеки.имя_функции"
- Вычисление md5 хэш списка

Наглядно, результат можно увидеть на примере сэмпла, который я скачал с сайта [vx-underground](https://vxug.fakedoma.in/samples.html), под названием *Backdoor.Win32.Agent.vuz.08248dd1e494f0cd7370067f430b3492*. Вот так выглядит его таблица адресов импортируемых функций (IAT):

![](/assets/images/ru/malware-identifying/peview_imports.png)

imphash в этом случае будет вычислен от следующей строки, которая является конкатенацией имен функций:

```
kernel32.getprocaddress,kernel32.loadlibrarya,kernel32.closehandle,kernel32.writefile,kernel32.createdirectorya,kernel32.gettemppatha,kernel32.readfile,kernel32.setfilepointer,kernel32.createfilea,kernel32.getmodulefilenamea,kernel32.getstringtypea,kernel32.lcmapstringw,kernel32.lcmapstringa,kernel32.heapalloc,kernel32.heapfree,kernel32.getmodulehandlea,kernel32.getstartupinfoa,kernel32.getcommandlinea,kernel32.getversion,kernel32.exitprocess,kernel32.heapdestroy,kernel32.heapcreate,kernel32.virtualfree,kernel32.virtualalloc,kernel32.heaprealloc,kernel32.terminateprocess,kernel32.getcurrentprocess,kernel32.unhandledexceptionfilter,kernel32.freeenvironmentstringsa,kernel32.freeenvironmentstringsw,kernel32.widechartomultibyte,kernel32.getenvironmentstrings,kernel32.getenvironmentstringsw,kernel32.sethandlecount,kernel32.getstdhandle,kernel32.getfiletype,kernel32.rtlunwind,kernel32.getcpinfo,kernel32.getacp,kernel32.getoemcp,kernel32.multibytetowidechar,kernel32.getstringtypew,user32.messageboxa,user32.wsprintfa
```

*Вы можете возразить, что идентификация упакованной малвари будет бесполезна, так как пакеры часто используют один и тот же набор функций (VirtualAlloc, GetProcAddress, LoadLibrary, ...). Предполагается, что анализ проводится над уже распакованным/сдампленым сэмплом.*

Минусы идентификации по imphash: 

- Много false positive. Одни и те же API могут использоваться в никак не связанных между собой программах
- Маленькая точность. Даже небольшое изменение списка функций координально изменяет хэш

Поэтому способ годится больше для первоначального анализа и получения списка сэмплов, которые требуют более пристального внимания.

В отличие от обычных PE программ, .NET программы импортируют только одну библиотеку "mscoree.dll", поэтому imphash к ним неприменим. Зато у .NET программ есть Metadata table. Metadata table содержит все используемые программой типы и неймспейсы. Их можно использовать для хэширования, вместо таблицы импортов классического PE файла. Такой  хэш назвали TypeRefHash.

> *[Оригинальное исследование](https://www.gdatasoftware.com/blog/2020/06/36164-introducing-the-typerefhash-trh)*
>
> *[Инструмент для вычисления TypeRefHash](https://github.com/GDATASoftwareAG/TypeRefHasher)*

В отличие от PE, у Mach-O файлов (формат в MacOS) совершенно другая структура. Поэтому для него придумали SymHash (аналог imphash).

> *[Статья о SymHash](https://www.anomali.com/blog/symhash)*
>
> *[Скрипт](https://github.com/threatstream/symhash), для вычисления SymHash*

Для ELF файлов существует несколько разных модификаций алгоритма вычисления хэша импортируемых функций. Одним из самых лучших на мой взгляд, является реализация от Trend Micro - Trend Micro ELF Hash. Они используют комбинированный подход с fuzzy hash (об этом позже).

> *[Статья о Trend Micro ELF Hash](https://blog.trendmicro.com/trendlabs-security-intelligence/grouping-linux-iot-malware-samples-with-trend-micro-elf-hash/)*
>
> *[Инструмент для вычисления аналога imphash для ELF на GO номер 1](https://github.com/malwaredb/imphash)* 
>
> *[Инструмент для вычисления аналога imphash для ELF номер 2](https://github.com/lief-project/LIEF/issues/54)*

## Предотвращение идентификации по imphash

Первый - это вызов и получение функций в рантайме, с помощью LoadLibrary/GetProcAddress. Таким образом список импортируемых функций будет похожим на списки огромного количества других программ.

> *[Пример из официальной документации](https://docs.microsoft.com/en-us/windows/win32/dlls/using-run-time-dynamic-linking)*

Второй - вручную менять порядок определений/вызовы функций в исходном коде или менять очередность передачи файлов компилятору. Если вы обратите внимание на оригинальный алгоритм, то в нем нет сортировки списка перед хэширование, из-за этого и появился такой способ обхода. К сожалению, изначальный алгоритм из скрипта pefile стал каноном и используется повсеместно (от всех известных инструментов до баз с малварью).

> *Способ обхода подробно описан в статье [Tracking Malware with Import Hashing](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html)*
>
> *[Модифицированный скрипт](https://github.com/malwaredb/imphash), который сортирует*

В статье "Tracking Malware with Import Hashing" утверждается, что функции, в таблице импортов PE файла, располагаются в том порядке, в котором они появляются в исходном коде. Я проверил и оказалось, что это справедливо только для программ, скомпилированных и слинкованных visual c++ build tools версий меньше 2013 (включительно). Если вы попытаетесь сделать то же самое, используя более новые build tools, то у вас ничего не получится. Поэтому этот способ я считаю устаревшим.

Третий - изменение таблицы импортов в уже скомпилированной программе. Алгоритм следующий (псевдокод):

```python 

thunk_data = [] # vector of (orig_thunk.addressofdata, thunk)

thunk_data_copy = [] # holds duplicate of thunk_data

original_to_new = {} # map<firstthunk, firstthunk>

for entry in DIRECTORY_ENTRY_IMPORT:
 for import in entry.imports:
 thunk_data.append((import.original_thunk.addressofdata,
 import.firstthunk))

thunk_data_copy = thunk_data.clone()

random_shuffle(thunk_data)

for i in range(thunk_data.length):
    original_to_new[thunk_data[i].second] = thunk_data_copy[i].second

for entry in DIRECTORY_ENTRY_IMPORT:
    i = 0
    for import in entry.imports:
        import.original_thunk.addressofdata =
        import.firstthunk.addressofdata = thunk_data[i].first
        i = i+1

for relocation_block in DIRECTORY_ENTRY_BASERELOC:
    for patch_address in relocation_block:
        lookup = patch_address - imagebase
        value = original_to_new.find(lookup)

    if value:
        relocation_block[patch_address] = value + imagebase
```

Алгоритм:

- Парсинг Import Directory Table
- Создание списка из элементов вида "OriginalFirstThunk + FirstThunk"
- Рандомное перемешивание списка
- Обновление таблицы импортов новыми значениями из списка
- Обновление [relocation структур](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-reloc-section-image-only)

Преимущества алгоритма - не требуется перекомпиляция/перелинковка оригинальной программы, функционал остается прежним.

> *[Подробнее читайте в оригинальном исследовании](https://arxiv.org/ftp/arxiv/papers/1909/1909.07630.pdf)*
>
> *[Исходный код инструмента breaking-imphash](https://github.com/scythe-io/breaking-imphash)*


## fuzzyhash

fuzzyhash (или по другому Context triggered piecewise hashes (CTPH))- алгоритм выявления похожих файлов. Алгоритм сравнивает хэши разных последовательностей байт двух файлов и выдает процент схожести между всеми последовательностями. Алгоритм, изначально, был  не был нацелен на идентификацию малвари, но исследователи малвари увидели в нем потенциал для своих задач. Таким образом его можно использовать, для выявления разных модификаций одной и той же малвари. 

> *[Интервью с чуваком](https://www.techrepublic.com/blog/it-security/fuzzy-hashing-helps-researchers-spot-morphing-malware/), который использовал fuzzyhash для малвари*

Изначальный алгоритм, использовавшийся в утилите dcfldd, хэшировал файл кусками фиксированной длины. Например, брали первые 512 байт файла, хэшировали, потом следующие 512 байт и так далее. Также поступаем и со сравниваемым файлом. Далее сравниваем эти два массива хэшей (фазим) и получаем процент схожести двух файлов. Такой способ называется хэшированием по кускам (Piecewise hashing).

Потом, этот алгоритм улучшили, и начали хэшировать не фиксированными кусками, а проходясь по изменяющимся последовательностям байтов с конца файла (rolling hashing). Этот улучшенный алгоритм и назвали fuzzyhash.

> *Об этом всем подробно читайте в исследовании [Identifying almost identical files using context triggered piecewise hashing](https://www.sciencedirect.com/science/article/pii/S1742287606000764?via%3Dihub)*

Я взял 80 гигабайт сэмплов малвари с сайта [vx-underground](https://vxug.fakedoma.in/samples.html) и сделал сравнение по fuzzyhash, программой [ssdeep](https://ssdeep-project.github.io/ssdeep/index.html). Сэмплы с этого сайта хороши тем, что они правильно проименованы.

Часть результата, в скобках процент схожести:

```
Backdoor.Win32.Agent.bkn.4d956a843fa431b608f426e15fb69520 matches Backdoor.Win32.Agent.bkn.026e279f2c16d654e17f6fb5c45e1741 (57)

Backdoor.Win32.Agent.bkoh.6a612dc284ef8d7f38304680a0e28693 matches Backdoor.Win32.Agent.bjup.961014b078122e628dbef050e58c9cd0 (99)

Backdoor.Win32.Agent.bkpe.f777700b6dfd3e11a808f81fdd494fb3 matches Backdoor.Win32.Agent.bjup.961014b078122e628dbef050e58c9cd0 (96)

Backdoor.Win32.Agent.bkpe.f777700b6dfd3e11a808f81fdd494fb3 matches Backdoor.Win32.Agent.bkoh.6a612dc284ef8d7f38304680a0e28693 (96)

Backdoor.Win32.Agent.bkqk.dafedf9521d55dbe25c68f3fcc9f970d matches Backdoor.Win32.Agent.bjup.961014b078122e628dbef050e58c9cd0 (97)

Backdoor.Win32.Agent.bkqk.dafedf9521d55dbe25c68f3fcc9f970d matches Backdoor.Win32.Agent.bkoh.6a612dc284ef8d7f38304680a0e28693 (97)

Backdoor.Win32.Agent.bkqk.dafedf9521d55dbe25c68f3fcc9f970d matches Backdoor.Win32.Agent.bkpe.f777700b6dfd3e11a808f81fdd494fb3 (96)

Backdoor.Win32.Agent.lei.08305b81ebfe3cfe37bcb1ec5e05531d matches Backdoor.Win32.Agent.hmv.845f009f63a39c2526ea8caba15c94a4 (55)

Backdoor.Win32.Agent.tyx.dcee8fe38cb66cefbb1cbee3f35b8107 matches Backdoor.Win32.Agent.qgq.734c8a4e104990bd785b1dc4ade1d5ac (61)

Backdoor.Win32.Agent.ucs.3dd15d055bb58c47ad6d48fa2009dca9 matches Backdoor.Win32.Agent.bkk.c29bc042c29b26ba7b43e035069cc673 (38)

Backdoor.Win32.Agent.ucv.d79281a60f0429c1846372a28084cfd0 matches Backdoor.Win32.Agent.ucq.5bee36b9e85e3d6afd5babf809eb4c9e (99)
```

Как видите, с помощью fuzzyhash, удалось определить схожие сэмплы, с разными хэшами.

> *[Описание улучшенного fuzzyhash алгоритм от Trend Micro](https://github.com/trendmicro/tlsh/blob/master/TLSH_CTC_final.pdf)*


## impfuzzyhash

По названию можно догадаться, что это комбинация imphash и fuzzyhash. Если раньше, два файла с почти одинаковой таблицой импорта, имели разные imphash, то теперь сравниваются куски этой таблицы (fuzzyhash). То есть, вычисляется процент схожести одной импорт таблицы с другой.  Данный подход убирает минусы оригинального алогритма и намного лучше выявляет схожесть.

> *Придумали этот способ в JPCERT. Статья [Classifying Malware using Import API and Fuzzy Hashing](https://blogs.jpcert.or.jp/en/2016/05/classifying-mal-a988.html)*
>
> *[Еще более улучшенный алгоритм impfuzzyhash от Trend Micro](https://gsec.hitb.org/materials/sg2019/D1%20-%20What%20Species%20of%20Fish%20Is%20This%20-%20Malware%20Classification%20with%20Graph%20Hash%20-%20Chia%20Ching%20Fang%20&%20Shih-Hao%20Weng.pdf), под название Call Graph Pattern, при котором сравниваются хэши вершин графа вызовов функций*

