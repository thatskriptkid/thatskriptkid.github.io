---
layout: post
title: Обзор анализатора исходного кода Microsoft Application Inspector. Что это и зачем.
tags: [windows, tool]
category: [ru]
---

![](/assets/images/ru/appinspector/4.png)

## Intro

_Факты:_

_96% всех приложений содержат open source код._

_60% энтерпрайз кода содержат уязвимости._


16-го января 2020 года, Microsoft [сообщили](https://www.microsoft.com/security/blog/2020/01/16/introducing-microsoft-application-inspector/), что выводят в open source анализатор исходников, под названием Application Inspector. 
Я расскажу вам, что это такое и зачем он нужен, а так же подробно покажу его работу. 

Исходники: https://github.com/microsoft/ApplicationInspector

Все скриншоты сделаны лично, за исключением скринов про Ruby бэкдор, их я взял из [этого видео](https://sector.ca/sessions/using-static-and-runtime-analysis-to-understand-third-party-applications/)


## Случай №1

Вы - разработчик и в проекте вам надо хэшировать строки. Вам выкатили требования - набор поддерживаемых алгоритмов и безопасность. Вы начинаете поиск подходящей библиотеки, читаете прилагаемые документацию и README, на предмет удовлетворения требованиям. Как можно быть точно уверенным, что выбранная библиотека поддерживает именно то, что заявляет? Как можно быть точно уверенным, что она не содержит алгоритма MD5, так как он подвержен коллизиям и это не совсем безопасно? Проблема в том, что документация не всегда содержит точные данные. 

1) Она может долгое время не обновляться
2) Она может врать
3) В ней забыли указать, что в последних трех версиях выпилили MD5
4) Ее может не быть совсем
5) Она полностью на китайском, а переводчик не справляется

_**Именно в этом вам поможет Microsoft AppInspector**_. Он парсит сам исходный код и поэтому точнее любой документации определит, какие алгоритмы точно есть, а каких нету.

_Пример результата анализа крипто библиотеки._

![](/assets/images/ru/appinspector/1.png)


_Вы можете кликнуть на каждый пункт и посмотреть соответствующий исходный код, что очень удобно_

![](/assets/images/ru/appinspector/5.png)

## Случай №2 

Вы отвечаете за проверку релиза перед выкатыванием на прод. Проект содержит кучу сторонних библиотек и представляет собой приложение, которое люди ставят на свои сервера. Приложение должно быть безопасным, поэтому вы используете очень дорогие security сканеры исходного кода. В проекте уже много лет используется библиотека по сжатию изображений. Она безопасна, тысячу раз проверена. Но появляется новая версия библиотеки и в нее встраивают работу с криптовалютой. 

_Как пример, я взял с гитхаба рандомную java библиотеку по **работе со строками** и AppInspector обнаружил, что она содержит код, для работы с криптовалютами. Интересно зачем? Ведь заявляется, что она просто конвертирует Object в String_

![](/assets/images/ru/appinspector/2.png)

Большинство security сканеров показывают лишь баги и код, с потенциальными уязвимостями. Они не заметят новый функционал, которым стал обладать код, так как попросту не заточены на это.

_**Именно в этом вам поможет Microsoft AppInspector**_. Вы сканируете им каждый свой релиз и получаете отчет. Сравнивая отчеты вы увидите вновь появившийся функционал. Вы можете просканировать особо критичные места и AppInspector покажет вам изменения. Например, работа с сетью в этом случае сразу бросится в глаза и будет изучена, а значит потенциальный бэкдор будет выявлен.

_Пример сравнения двух версий файла на имеющиеся фичи. В новой версии вдруг неожиданно появилась работа с сетью. Это был был бэкдор в open source Ruby библиотеке strong_password. [Ссылка на новость](https://withatwist.dev/strong-password-rubygem-hijacked.html)_

_Командой tagdiff видим, что появилась фича OS.Network.Connect_

![](/assets/images/ru/appinspector/6.png)

![](/assets/images/ru/appinspector/7.png)

К этой статье я хотел подготовить примеры по сканированию open source проектов, в которые были встроены бэкдоры, но к сожалению, такие релизы выпиливают с RubyGems, NuGet и Github и нет возможности их найти. Поэтому просто привожу ссылки:

[Malicious code found in npm package event-stream downloaded 8 million times in the past 2.5 months](https://snyk.io/blog/malicious-code-found-in-npm-package-event-stream/)

[Version 1.6.13 published with malicious backdoor.](https://github.com/rest-client/rest-client/issues/713)

## Случай №3

Вы - пентестер, и вам поручили проанализировать огромную кучу ~~говна~~ кода. Прогнав типичные сканеры, вы получили места с уязвимым кодом и багами. Изучая только их, вы не видите всей картины в целом. Вы не увидите места в коде, которые открывают новые вектора атак. Чтобы найти потенциальные вектора атак, вы должны задать себе и коду вопросы:

_Есть ли тут работа с сетью?_

_А прямое исполнение команд?_

_А интеграция с Microsoft Azure?_

_А работа именно с PostgreSQL, так как вышел свежий эксплоит?_

...

В таких ситуациях, мне приходилось читать документацию по каждому пункту, чтобы понять, как называются конкретные методы API и как правильно составить регулярное выражение, чтобы найти всё что требуется. Проблема усугубляется, когда в проекте используется 7 языков программирования, а знаете вы лишь 2-3. Времени гуглить и составлять регулярные выражения на каждый чих нету.

_**Именно в этом вам поможет Microsoft AppInspector**_. Он покажет места, на которые стоит обратить особое внимание. Например, проект содержит код, для работы с облаками Амазона. Код безопасен на 100% и уязвимостей не содержит. Он также не является говнокодом. Сканеры безопасности никогда на него не укажут и вы можете никогда не узнать о его существовании. AppInspector же покажет весь имеющийся функционал, в том числе и работу с облаками, что поможет вам придумать новый сценарий атаки (например спуфинг DNS имен).

_Фичи категории Cloud Services_

![](/assets/images/ru/appinspector/3.png)

## Промежуточный итог

 Как вы поняли, AppInspector не является заменой сканеров безопасности и нисколько на это не претендует. Наоборот, его надо использовать в связке. Если в вашем проекте миллион строк open source кода, то все просмотреть руками затратно и надо выставить приоритеты. 

Насколько эффективен поиск по API предлагаемый AppInspector'ом? Как не крути, если вам надо прочитать файл, открыть сокет, выделить память, вы неизбежно будете использовать стандартный API, который легко детектить.

Если говорить совсем просто, то AppInspector позволяет вам очень быстро понять ЧТО делает код. 

## Общий обзор

Первое, на что хочется обратить внимание, это то что AppInspector - это тупо набор регулярных выражений. Давайте посмотрим на одно из правил по определению функционала, связанного с социальными сетями

```json
{
    "name": "Social Media: Misc",
    "id": "AI004100",
    "description": "Social Media: Misc",
    "tags": [
      "CloudServices.SocialMedia.Misc"
    ],
    "severity": "moderate",
    "patterns": [
      {
        "pattern": "reddit|snapchat|whatsapp|tumblr|qzone|weibo|pinterest|ask\\.fm|flickr|linkedin|odnoklassniki|meetup",
        "type": "regex",
        "scopes": [ "code", "comment" ],
        "modifiers": [ "i" ],
        "confidence": "high"
      },
      {
        "pattern": "discord|diaspora|sociall\\.io|mastodon",
        "type": "regex",
        "scopes": [ "code", "comment" ],
        "modifiers": [ "i" ],
        "confidence": "high"
      }
    ]
  }
```

Здесь вы можете заметить поле `severity`. Оно говорит о степени "интересности" данной фичи. Другим словами, на что стоит обратить внимание. Вы можете изменить его на `high`, если анализируемый проект не предполагает связи с соц. сетями.

Такие json файлы с правилами, тут называются rules и лежат в папке (не поверите) rules. Естественно, вы вольны писать свои rules и активно использовать при анализе. 

Одним из преимуществ AppInspector - сканирование проектов, в которых используется сразу несколько языков программирования.

_Список поддерживаемых языков:_
_C,C++,C#,Python, HTML, JavScript, TypeScript, Java, Objective-C, Ruby, Powershell, PHP_

В последней версии добавлена поддержка Dart. 

Я советую вам самим прочитать исходники rules, которые идут в комплекте и решить самим, подходят ли они вам. Некоторые стандартные rules довольно простые и иногда бесполезные. Например, вот правило для языков С/С++

```json
[
  {
    "name": "Development Framework: Standard C Library",
    "id": "AI017900",
    "description": "Development Framework: Standard C Library",
    "recommendation": "",
    "applies_to": [ "c" ],
    "tags": [ "Framework.Development.Library.StandardC" ],
    "severity": "moderate",
    "patterns": [
      {
        "pattern": "std::",
        "type": "string",
        "scopes": [ "code" ],
        "modifiers": [ "i" ]
      }
    ]
  },
  {
    "name": "Development Framework: Boost",
    "id": "AI018000",
    "description": "Development Framework: Boost",
    "recommendation": "",
    "applies_to": [ "c" ],
    "tags": [ "Framework.Development.Library.Boost" ],
    "severity": "moderate",
    "patterns": [
      {
        "pattern": "boost::",
        "type": "string",
        "scopes": [ "code" ],
        "modifiers": [ "i" ]
      },
      {
        "pattern": "#include <boost/.*>",
        "type": "regex",
        "scopes": [ "code" ],
        "modifiers": [ "i" ]
      }
    ]
  }
]
```

Давайте теперь посмотрим на интерфейс сканера. После того, как вы проанализируете проект, вам генерят HTML отчет, который еще можно выгрузить как plain text и JSON. 

_Люди просили Microsoft запилить загрузку результата в базу, но так как есть JSON, этот функционал можно реализовать самому_

В _Project Info_ нам показывают количество проанализированных файлов. Skipped файлы - это конфиги, скрипты сборки и остальные неинтересные нам файлы. Наглядно показано количество языков.

![](/assets/images/ru/appinspector/8.png)

В _Metadata_ показывают тип приложения (в данном случае - web) и типы файлов в проекте, а также поддерживаемые библиотекой операционные системы.

![](/assets/images/ru/appinspector/9.png)

Кстати, кликнув по типу файла, открывается сайт с описанием что это и для чего

![](/assets/images/ru/appinspector/9_2.png)

В tag list'e перечислены фичи, которые были найдены регулярками

![](/assets/images/ru/appinspector/10.png) 

Количество найденных вхождений

![](/assets/images/ru/appinspector/11.png) 

Во вкладке Features находится самая основная информация, разбитая на группы

![](/assets/images/ru/appinspector/12.png) 

Далее я просто приведу скриншоты каждой группы и их содержание. Не забывайте, что все найденные фичи кликабельны и открывают соответсвующее место в коде. Данные скрины помогут вам понять, какими возможностями обладает AppInspector.

![](/assets/images/ru/appinspector/feature_1.png)

![](/assets/images/ru/appinspector/feature_2.png)

![](/assets/images/ru/appinspector/feature_3.png)

![](/assets/images/ru/appinspector/feature_4.png)

![](/assets/images/ru/appinspector/feature_5.png)

![](/assets/images/ru/appinspector/feature_6.png)

![](/assets/images/ru/appinspector/feature_7.png)

![](/assets/images/ru/appinspector/feature_8.png)

![](/assets/images/ru/appinspector/feature_9.png)

![](/assets/images/ru/appinspector/feature_10.png)

## Итог

Хорошая идея с довольно примитивной реализацией. Но факт остается фактом - при ручном анализе мы часто юзаем регулярные выражения и иметь готовый инструмент, с понятным отчетом это неплохо. Не надо также забывать, что проект open source'ный и мы сами можем добавить кучу фич. Из заявленных Microsoft - анализ _**бинарников**_ (ура!). 

Всем спасибо за внимание!
