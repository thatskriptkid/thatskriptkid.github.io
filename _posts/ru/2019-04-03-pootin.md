---
layout: post
title: Собираем базу номеров с приложения Pootin
tags: [android]
category: [ru]
---

## Intro

Впервые я рассказал об этом в презентации на 2600-Qazaqstan (08.08.18), на тот момент приложение уже не функционировало и я свободно мог рассказать, как его парсить.

Все вы слышали о [GetContact](https://www.getcontact.com/ru/), приложении позволяющем посмотреть, как вы подписаны в телефонной книге у других людей. В свое время оно наделало много шума, например его заблокировали в Казахстане. Сразу же после выхода этого приложения, казахстанские разработчики выпустили свой аналог, под названием *Pootin*, с тем же функционалом, но с более обширной базой данной пользователей. На то время, защита от реверса в Pootin была на уровень выше, чем в GetContact, что немного удивило. Но ничего страшного! 

Анализируя мобильные приложения, мы делаем все по классике, закидываем сертификат burp на эмулятор, и запускаем там приложение. SSL pining отсутствовал. Функционал приложения прост - вы вводите номер телефона в поле, вам выдается список имен. 

Вот так выглядит запрос по конкретному номеру телефона:

![](/assets/images/ru/Pootin/2-request.png)

Сервер нам отвечает:

![](/assets/images/ru/Pootin/3-response.png)

В запросе, нас особо интересует следующее:

![](/assets/images/ru/Pootin/4-request%20important%20data.png)

**AUTH TOKEN** 
* Константное значение в каждом запросе
* Скорее всего, приложение его генерирует, при установке, для каждого отдельного девайса

**CSRF TOKEN**
* Всегда новый
* Надо понять, как он генерится

Если мы посмотрим внимательней на CSRF токен

![](/assets/images/ru/Pootin/6-timestamp.png)

Похоже на unix timestamp, не правда ли?

![](/assets/images/ru/Pootin/7-token.png)

Возьмем первые 10 цифр и сконвертируем

![](/assets/images/ru/Pootin/7-token%20timestamp.png)

Да, похоже на правду! Если сделать несколько запросов, то можно заметить букву 'a' на конце

![](/assets/images/ru/Pootin/8-a%20letter.png)

Итак, что имеем на данный момент?
* Длина всей строки с csrf токеном равна 46
* Первые 10 символов — время запроса
* Последний символ — буква 'а'
* Откуда берутся остальные 35 символов?

Для этого, обратимся к исходникам. Получить их можно, декомпилировав apk.

![](/assets/images/ru/Pootin/10-apk-decompile.png)

Делаем поиск строки 'csrf' по исходникам (да, это total commander)

![](/assets/images/ru/Pootin/11-sources.png)

Видим вот такой вот метод _AppConstants.INSTANCE.getCsrfToken()_

![](/assets/images/ru/Pootin/12-sources.png)

![](/assets/images/ru/Pootin/13-sources.png)

Откроем же наконец исходник AppConstant

![](/assets/images/ru/Pootin/14-sources.png)

Внутри вызывается метод с модификатором native. Модификатор native означает, что реализация метода находится в библиотеках, написанных на других языках. Чтобы работать с такими библиотеками, используется механизм JNI (Java Native Interface). Это значит, что приложение использует внешнюю библиотеку, которая генерит csrf токен. 

![](/assets/images/ru/Pootin/15-sources.png)

Делаем поиск по исходникам по слову 'loadlibrary' или же 'lib', в надежде найти место, где подгружаются какие-нибудь библиотеки.

![](/assets/images/ru/Pootin/16-sources.png)

Или же тупо распаковываем apk и смотрим папку lib

![](/assets/images/ru/Pootin/18-sources.png)

Открываем библиотеку в IDA, открываем окно Functions (Shift + F3), видим нашу функцию

![](/assets/images/ru/Pootin/19-sources.png)

Тело функции

![](/assets/images/ru/Pootin/20-sources.png)

После того, как мы получил UNIX timestamp, мы умножаем его на 1000, чтобы получить миллисекундную часть. Поэтому наш timestamp становится длиной 13 символов.

![](/assets/images/ru/Pootin/21-IDA.png)

![](/assets/images/ru/Pootin/22-IDA.png)

На предыдущем шаге мы соединили timestamp (включая секунды) с "TtaaTTaaRaUaNTTaaTTaab". Затем вызываем метод getMd5() из AppConstants, хэшируем результирующую строку. В итоге получаем 32 байта хэша.

_Длина всей строки с csrf токеном равна 46_
_Первые 10 символов — время запроса_
_Последний символ — буква 'а'_
_Откуда берутся остальные 35 символов?_

Ответ:

* 32 символа — md5 хэш (timestamp + constant string)
* 3 символа — секунды у timestamp

Итоговый скрипт:

```python
salt  = r"TTaaTTaaRaUaNTTaaTTaab"

def getSalt():

    ts = int(time.time()*1000)

    h = hashlib.md5()

    h.update(b"%d%s" % (ts, salt.encode()))

    return "%d%sa" % (ts, h.hexdigest())
```